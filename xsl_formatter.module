<?php
/**
 * @file a formatter that runs given XML content through a defined
 * XSL stylesheet before rendering.
 *
 *  When enabled, this provides an additional field formatter available
 *  through 'manage display' for use entity displays or views.
 *  The data source should be a textarea witch contains the raw XML
 *  and configuration options on the display widget will allow you to
 *  define the XSL that should be run over it.
 *
 *  The textarea should contain valid XML, and the XSL should produce an HTML
 *  snippet, as the result will be displayed inline in the page.
 *
 *  This process can ALSO run identically over a link field.
 *  Add a 'link' field to your page, and choose 'Transformed by XSL' as the
 *  renderer.
 *  On each request, that file will be fetched, parsed, transformed and
 *  rendered.
 *
 * Other projects
 * ==============
 *
 * Built with *some* comparison to
 *
 * http://drupal.org/project/cck_xslt D6 unreleased
 * - which  made its own field and data storage instead of re-using a text field.
 * - Has the XSL selection a per-node choice, not a field formatter.
 * - did demonstrate how easy it was to extend to reading an URL instead of text.
 *
 * http://drupal.org/project/feeds_xsltparser D7 dev
 * - Not incredibly similar, but nice to see!
 *
 * http://drupal.org/node/1476774 "XML Transform" Never released
 * - Uses the Drupal text filter system to process a textarea with XSL.
 * - Actually the first way I started thinking about it, as I've done multiple
 *   XML-based text filters already.
 *
 *
 * @author Dan Morrison (dman) dan@coders.co.nz
 * @version 2012-11-27 (1:00AM -3:30AM)
 */


/**
 * Implements hook_field_formatter_info().
 *
 * Declares the existance of this formatter.
 * We can do similar things to local textareas, remote URLs, or uploaded files!
 */
function xsl_formatter_field_formatter_info() {
  $info = array(
    'xsl' => array(
      'label' => t('Transformed by XSL'),
      'field types' => array('text', 'link', 'filefield'),
      'settings' => array(
        'xsl_path' => 'xsl/xmlverbatim.xsl',
        'xsl_params' => '',
        'debug' => FALSE,
      ),
    ),
  );

  foreach (xsl_formatter_enumerate_xsls() as $xsl_path => $label) {
    $info[$label] = array(
      'label' => t('Transformed by XSL ' . $label),
      'field types' => array('text', 'link', 'filefield'),
      'settings' => array(
        'xsl_path' => 'xsl/xmlverbatim.xsl',
        'xsl_params' => '',
        'debug' => FALSE,
      ),
    );
  }

  return $info;
}


/**
 * Theme function for 'xsl_formatter' which can run on (various) field formatters.
 * theme_{modulename}_formatter_{format_style}()
 *  @see xsl_formatter_field_formatter_info()
 */
function theme_xsl_formatter_formatter_xsl($element) {
  // Backport this to a call to the D7 formatter_view func.
  // Rather than rebuild all the logic, just call it. func sig is totally different though.
  $entity_type = 'node';
  $entity = $element['#node'];
  $field_name = $element['#field_name'];
  $field = content_fields($field_name, $entity->type);
  $instance = NULL;
  $langcode = NULL;
  $items = array($element['#item']);
  $display = array('settings' => array('xsl_path' => 'xsl/prettyprint.xsl', 'xsl_params' => ''));
  // Based on the formatter ID we were given, set the xsl_path
  if (! empty($element['#formatter'])) {
    $xsls = array_flip(xsl_formatter_enumerate_xsls());
    if (!empty($xsls[$element['#formatter']])) {
      $display['settings']['xsl_path'] = $xsls[$element['#formatter']];
    }
  }
  $renderable = xsl_formatter_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  return drupal_render($renderable);
}


/**
 * Implements hook_field_formatter_view().
 *
 * Does the process here, to generate the result.
 * Delegates the final layout to the theme func
 */
function xsl_formatter_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $item) {

    $result = "Can't parse the XML input";
    $data = @$item['value'];
    $xml_doc = new domdocument;

    // Alternate field types. Local data (valus) is easiest, but
    // If the field type is a link, go get that data now
    // DESPERATELY need caching or something here.
    if ($field['type'] == 'link') {
      $url = url($item['url'], $item);
      $data = file_get_contents($url);
    }
    // Or files, why not?
    if ($field['type'] == 'filefield') {
      $data = file_get_contents($item['filepath']);
    }

    try {
      // Warnings may go to the screen.
      $xml_doc->loadXML($data);
    } catch (Exception $e) {
      throw new Exception("Unable to parse the data. Probably invalid XML. " . $e->getMessage(), E_USER_ERROR);
    }

    // XML Loaded OK. Now load the stylesheet.
    try {
      $xsl_path = $display['settings']['xsl_path'];
      $xsl_doc = xsl_formatter_get_xml_doc($xsl_path);
      if ($xsl_doc) {
        // Pass through any params that the XSLT may want.
        $params = (array)json_decode($display['settings']['xsl_params']);
        // 'base' can be used for supporting relative css links.
        $params['base'] = url(dirname($xsl_doc->documenturi));
        // Transform!
        $result = xsl_formatter_xmldoc_plus_xsldoc($xml_doc, $xsl_doc, $params);
      }
      else {
        throw new Exception("Failed to load XSL. Probably invalid. $xsl_path " . $e->getMessage(), E_USER_ERROR);
      }
    }
    catch (Exception $e) {
      throw new Exception("Unable to run the transformation. Probably invalid XSL. $xsl_path. " . $e->getMessage(), E_USER_ERROR);
    }

    $element[$delta] = array(
      '#theme' => 'xsl_formatter',
      '#item' => $item,
      '#settings' => $display['settings'],
      '#result' => $result,
    );
  }
  return $element;
}


/**
 * Implements hook_theme().
 *
 * Advertises our theme functions.
 */
function xsl_formatter_theme() {
  $theme = array(
    'xsl_formatter_formatter_xsl' => array(
      'arguments' => array(
        'item' => NULL,
        'settings' => NULL,
        'result' => NULL,
      ),
    ),
    'xsl_formatter' => array(
      'arguments' => array(
        'item' => NULL,
        'settings' => NULL,
        'result' => NULL,
      ),
    ),
  );
  // Support infinite settings, same way imagecache did
  foreach (xsl_formatter_enumerate_xsls() as $xsl_path => $label) {
    $theme['xsl_formatter_formatter_' . $label] = array(
      'arguments' => array('element' => NULL),
      'function' => 'theme_xsl_formatter_formatter_xsl',
    );
  }
  return $theme;
}

/**
 * Returns HTML from passing the input through the XSL process
 *
 * @param $variables
 *   An associative array containing:
 *   - item: An array of field data.
 *   - settings: used to do the transform, including the xsl path
 *   - result: the rendered result.
 *
 * @ingroup themeable
 */
function theme_xsl_formatter($variables) {
  // The data is already cooked, just use this theme func to stick a
  // wrapper around it if you want.
  return @$variables['#result'];
}

/**
 * Return a list of xsl files, as found in the search locations
 * Over-engineerd for now, anticipating 'module:// as a file scheme
 * and keeping the UI simpler (?)
 */
function xsl_formatter_enumerate_xsls() {
  $paths = array('public://xsl', 'module://xsl_formatter/xsl');
  $found = array();
  foreach ($paths as $base) {
    $label = $base;

    // Just me being cute here...
    $target_path = xsl_formatter_file_uri_target($base);
    if (xsl_formatter_file_uri_scheme($base) == 'module') {
      $split_path = explode('/', $target_path);
      $module_name = array_shift($split_path);
      $base = drupal_get_path('module' , $module_name) .'/'. join('/', $split_path);
    }
    if (xsl_formatter_file_uri_scheme($base) == 'public') {
      $base = file_directory_path() . '/'. $target_path;
    }

    $files = file_scan_directory($base, '\.xsl$');
    foreach ($files as $file) {
      // Need a really flattened basename for a style ID...
      $found[$file->filename] = $id = preg_replace('/[^a-zA-Z0-9]+/', '_', $file->basename);
    }
  }
  return $found;
}

/**
 * Returns the schema part of a URI.
 *
 * backport from D7
 */
function xsl_formatter_file_uri_scheme($uri) {
  $position = strpos($uri, '://');
  return $position ? substr($uri, 0, $position) : FALSE;
}

/**
 * Returns the part of a URI after the schema.
 *
 * backport from D7
 */
function xsl_formatter_file_uri_target($uri) {
  $data = explode('://', $uri, 2);

  // Remove erroneous leading or trailing, forward-slashes and backslashes.
  return count($data) == 2 ? trim($data[1], '\/') : FALSE;
}



/////////////////////////
// XML utilities below.
// Ultra-paranoid and layered with pessimism.
// Because XML always goes wrong.

/**
 * Find and initialize the transformation template.
 *
 * LOTS of error checking.
 *
 * Allows you to define the path relative to the module, the site,
 * or the files dir.
 *
 * Includes caching retrieval for a bit of speed-up over bulks.
 * XSL is expensive, so if we find ourselves doing it more than once,
 * the parsed file is retained for next time.
 *
 * Throws an exception if anything goes wrong.
 *
 * @return XML Document
 */
function xsl_formatter_get_xml_doc($xml_file, $description = "XML file") {
  // Check cache first-off.
  static $xmldocs;
  if (isset($xmldocs[$xml_file])) {
    return $xmldocs[$xml_file];
  }
  if (empty($xml_file)) {
    throw new Exception("Null $description? Cannot proceed", E_USER_ERROR);
  }

  // Check if and where filepath can be found.
  // Search first under full path, then under files dir, then module dir.

  # TODO - check if this could be used as an attack vector?
  # Sanitize the fetch path.

  $xml_filepath = $xml_file;
  if (!is_file($xml_filepath)) {
    $xml_filepath = file_directory_path() . '/' . $xml_file;
  }
  if (!is_file($xml_filepath)) {
    $xml_filepath = drupal_get_path('module', 'xsl_formatter') . "/$xml_file";
  }

  if (is_file($xml_filepath)) {
    #watchdog(__FUNCTION__, "Loading $description from $xml_filepath", array(), WATCHDOG_DEBUG);
    $xml_doc = new domdocument;
    if ($xml_doc->load($xml_filepath) ) {
      // Loaded OK.
      // .yay.
    }
    else {
      $xmldocs[$xml_file] = FALSE;
      throw new Exception("Unable to parse the $description '$xml_filepath' ", E_USER_ERROR);
    }

    $xml_docs[$xml_file] = $xml_doc;
  }
  else {
    $xmldocs[$xml_file] = FALSE;
    throw new Exception("Unable to locate the $description '$xml_file' ", E_USER_ERROR);
  }

  // This is required/helpful to support relative includes
  $xml_doc->documenturi = $xml_filepath;

  return $xml_doc;
}

/**
 * Do the actual conversion between XML+XSL
 *
 * Input and output are full DOM objects in PHP5
 * We return the result STRING, as that's what
 * the process gives us :-/
 * Need to parse it back in again for pipelining.
 *
 * Support for PHP4 XSL removed.
 *
 * @param domdocument or string $xmldoc
 *
 * @param domdocument or string $xsldoc . If it uses includes, the xsl must have
 * had its documenturi set correctly prior to this, but it can be set in the
 * parameters also.
 *
 * @param array $parameters To be passed into the xslt_process()
 *
 * @returns string The result.
 */
function xsl_formatter_xmldoc_plus_xsldoc($xml_doc, $xsl_doc, $parameters = array()) {
  $xsltproc = new XSLTProcessor;

  // Attach the xsl rules.
  $xsltproc->importStyleSheet($xsl_doc);
  // Set any processing parameters and flags.
  if ($parameters) {
    foreach ($parameters as $param => $value) {
      $xsltproc->setParameter("", $param, $value);
    }
  }

  $out = $xsltproc->transformToXml($xml_doc);

  if (function_exists('charset_decode_utf_8')) {
    // I just CAN'T trust XML not to have squashed the entities into bytecodes.
    // Expand them before returning or I can never trust that my result here
    // is actually valid to put in anywhere else again.
    return charset_decode_utf_8($out);
  }

  return $out;
}

